# Problem:
#
# Write a function, parenthetical_possibilities, that takes in a string as an argument. The function should return an array containing all of the strings that could be generated by expanding all parentheses of the string into its possibilities.
#
# For example, the possibilities for 'x(mn)yz' are 'xmyz', 'xnyz'.
#


# Solution:
#
# 1. Iterate
# 2. Look at the front
#    a. If anything not in (), take the character as is
#    b. If inside (), branch out to each item inside the ()
# 3. Tack on the first item
# 4. Have a helper function get_options to parse out choices inside of a () or just character


def parenthetical_possibilities(s):
    if len(s) == 0:
        return ['']
    remaining, chars = get_options(s)
    suffixes = parenthetical_possibilities(remaining)
    possibilities = []
    for char in chars:
        possibilities += [char + suffix for suffix in suffixes]
    return possibilities


def get_options(s):
    if s[0] == '(':
        idx = s.index(')')
        chars = s[1:idx]
        remaining = s[idx + 1:]
        return (remaining, chars)
    else:
        chars = s[0]
        remaining = s[1:]
        return (remaining, chars)


print(parenthetical_possibilities("(qr)ab(stu)c")) # ->
# [ 'qabsc', 'qabtc', 'qabuc', 'rabsc', 'rabtc', 'rabuc' ]